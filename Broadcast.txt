public static int findBroadcastLevel(long root) {
    var addrSize = BitOperations.Log2((ulong)MPI.NodeCount);

    for (int i = addrSize - 1; i >= 0; i--) {
        var mask = 1 << i;
        var result = (root ^ IAm) & mask;
        if (result != 0) {
            return i;
        }
    }
    return 0; // This is the source, as there are no different digits.
}

public static void BroadcastJP<T>(ref T text, long root) {
    var addrSize = BitOperations.Log2((ulong)MPI.NodeCount);
    long mask = 1;
    long lastDimMask = 1 << addrSize - 1;
    Boolean isSource = root == IAm;
    Boolean msgReceived = false;

    var bCastLevel = findBroadcastLevel(root);
    // These two lines are necessary to "calibrate" where in the process
    mask <<= bCastLevel;
    addrSize -= bCastLevel;

    while (addrSize > 0) {
        var low = IAm & ~mask;
        var high = IAm | mask;
        var iamLow = IAm == low;

        // This very obscure algorithm is a reduction of a much more
        // transparent algorithm, but that required far more operations
        // and tests to be performed. What is left is the kernel.

        if (isSource || msgReceived) {
            if (Debugging)
                Console.WriteLine("{0} send to {1}",
                            MPI.IAm, iamLow ? high : low);
            MPI.SendMsg(iamLow ? high : low, text);
        } else {
            if (Debugging)
                Console.WriteLine("{0} recv fr {1}",
                            MPI.IAm, iamLow ? high : low);
            text = MPI.RecvText<T>();
            msgReceived = true; // We have received the message, so switch to send mode.
            if (Debugging)
                Console.WriteLine("{0} received {1}", MPI.IAm, text);
        }

        // on to the next dimension.

        addrSize--;
        mask <<= 1;
    }

    MPI.Barrier(73);
}
